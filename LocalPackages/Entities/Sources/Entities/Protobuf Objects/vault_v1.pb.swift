// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vault_v1.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum ProtonPassVaultV1_VaultIcon: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case iconUnspecified // = 0
  case iconCustom // = 1
  case icon1 // = 2
  case icon2 // = 3
  case icon3 // = 4
  case icon4 // = 5
  case icon5 // = 6
  case icon6 // = 7
  case icon7 // = 8
  case icon8 // = 9
  case icon9 // = 10
  case icon10 // = 11
  case icon11 // = 12
  case icon12 // = 13
  case icon13 // = 14
  case icon14 // = 15
  case icon15 // = 16
  case icon16 // = 17
  case icon17 // = 18
  case icon18 // = 19
  case icon19 // = 20
  case icon20 // = 21
  case icon21 // = 22
  case icon22 // = 23
  case icon23 // = 24
  case icon24 // = 25
  case icon25 // = 26
  case icon26 // = 27
  case icon27 // = 28
  case icon28 // = 29
  case icon29 // = 30
  case icon30 // = 31
  case UNRECOGNIZED(Int)

  public init() {
    self = .iconUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .iconUnspecified
    case 1: self = .iconCustom
    case 2: self = .icon1
    case 3: self = .icon2
    case 4: self = .icon3
    case 5: self = .icon4
    case 6: self = .icon5
    case 7: self = .icon6
    case 8: self = .icon7
    case 9: self = .icon8
    case 10: self = .icon9
    case 11: self = .icon10
    case 12: self = .icon11
    case 13: self = .icon12
    case 14: self = .icon13
    case 15: self = .icon14
    case 16: self = .icon15
    case 17: self = .icon16
    case 18: self = .icon17
    case 19: self = .icon18
    case 20: self = .icon19
    case 21: self = .icon20
    case 22: self = .icon21
    case 23: self = .icon22
    case 24: self = .icon23
    case 25: self = .icon24
    case 26: self = .icon25
    case 27: self = .icon26
    case 28: self = .icon27
    case 29: self = .icon28
    case 30: self = .icon29
    case 31: self = .icon30
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .iconUnspecified: return 0
    case .iconCustom: return 1
    case .icon1: return 2
    case .icon2: return 3
    case .icon3: return 4
    case .icon4: return 5
    case .icon5: return 6
    case .icon6: return 7
    case .icon7: return 8
    case .icon8: return 9
    case .icon9: return 10
    case .icon10: return 11
    case .icon11: return 12
    case .icon12: return 13
    case .icon13: return 14
    case .icon14: return 15
    case .icon15: return 16
    case .icon16: return 17
    case .icon17: return 18
    case .icon18: return 19
    case .icon19: return 20
    case .icon20: return 21
    case .icon21: return 22
    case .icon22: return 23
    case .icon23: return 24
    case .icon24: return 25
    case .icon25: return 26
    case .icon26: return 27
    case .icon27: return 28
    case .icon28: return 29
    case .icon29: return 30
    case .icon30: return 31
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [ProtonPassVaultV1_VaultIcon] = [
    .iconUnspecified,
    .iconCustom,
    .icon1,
    .icon2,
    .icon3,
    .icon4,
    .icon5,
    .icon6,
    .icon7,
    .icon8,
    .icon9,
    .icon10,
    .icon11,
    .icon12,
    .icon13,
    .icon14,
    .icon15,
    .icon16,
    .icon17,
    .icon18,
    .icon19,
    .icon20,
    .icon21,
    .icon22,
    .icon23,
    .icon24,
    .icon25,
    .icon26,
    .icon27,
    .icon28,
    .icon29,
    .icon30,
  ]

}

public enum ProtonPassVaultV1_VaultColor: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case colorUnspecified // = 0
  case colorCustom // = 1
  case color1 // = 2
  case color2 // = 3
  case color3 // = 4
  case color4 // = 5
  case color5 // = 6
  case color6 // = 7
  case color7 // = 8
  case color8 // = 9
  case color9 // = 10
  case color10 // = 11
  case UNRECOGNIZED(Int)

  public init() {
    self = .colorUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .colorUnspecified
    case 1: self = .colorCustom
    case 2: self = .color1
    case 3: self = .color2
    case 4: self = .color3
    case 5: self = .color4
    case 6: self = .color5
    case 7: self = .color6
    case 8: self = .color7
    case 9: self = .color8
    case 10: self = .color9
    case 11: self = .color10
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .colorUnspecified: return 0
    case .colorCustom: return 1
    case .color1: return 2
    case .color2: return 3
    case .color3: return 4
    case .color4: return 5
    case .color5: return 6
    case .color6: return 7
    case .color7: return 8
    case .color8: return 9
    case .color9: return 10
    case .color10: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [ProtonPassVaultV1_VaultColor] = [
    .colorUnspecified,
    .colorCustom,
    .color1,
    .color2,
    .color3,
    .color4,
    .color5,
    .color6,
    .color7,
    .color8,
    .color9,
    .color10,
  ]

}

public struct ProtonPassVaultV1_VaultDisplayPreferences: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var icon: ProtonPassVaultV1_VaultIcon = .iconUnspecified

  public var color: ProtonPassVaultV1_VaultColor = .colorUnspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ProtonPassVaultV1_Vault: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var description_p: String = String()

  public var display: ProtonPassVaultV1_VaultDisplayPreferences {
    get {return _display ?? ProtonPassVaultV1_VaultDisplayPreferences()}
    set {_display = newValue}
  }
  /// Returns true if `display` has been explicitly set.
  public var hasDisplay: Bool {return self._display != nil}
  /// Clears the value of `display`. Subsequent reads from it will return its default value.
  public mutating func clearDisplay() {self._display = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _display: ProtonPassVaultV1_VaultDisplayPreferences? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proton_pass_vault_v1"

extension ProtonPassVaultV1_VaultIcon: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ICON_UNSPECIFIED"),
    1: .same(proto: "ICON_CUSTOM"),
    2: .same(proto: "ICON1"),
    3: .same(proto: "ICON2"),
    4: .same(proto: "ICON3"),
    5: .same(proto: "ICON4"),
    6: .same(proto: "ICON5"),
    7: .same(proto: "ICON6"),
    8: .same(proto: "ICON7"),
    9: .same(proto: "ICON8"),
    10: .same(proto: "ICON9"),
    11: .same(proto: "ICON10"),
    12: .same(proto: "ICON11"),
    13: .same(proto: "ICON12"),
    14: .same(proto: "ICON13"),
    15: .same(proto: "ICON14"),
    16: .same(proto: "ICON15"),
    17: .same(proto: "ICON16"),
    18: .same(proto: "ICON17"),
    19: .same(proto: "ICON18"),
    20: .same(proto: "ICON19"),
    21: .same(proto: "ICON20"),
    22: .same(proto: "ICON21"),
    23: .same(proto: "ICON22"),
    24: .same(proto: "ICON23"),
    25: .same(proto: "ICON24"),
    26: .same(proto: "ICON25"),
    27: .same(proto: "ICON26"),
    28: .same(proto: "ICON27"),
    29: .same(proto: "ICON28"),
    30: .same(proto: "ICON29"),
    31: .same(proto: "ICON30"),
  ]
}

extension ProtonPassVaultV1_VaultColor: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COLOR_UNSPECIFIED"),
    1: .same(proto: "COLOR_CUSTOM"),
    2: .same(proto: "COLOR1"),
    3: .same(proto: "COLOR2"),
    4: .same(proto: "COLOR3"),
    5: .same(proto: "COLOR4"),
    6: .same(proto: "COLOR5"),
    7: .same(proto: "COLOR6"),
    8: .same(proto: "COLOR7"),
    9: .same(proto: "COLOR8"),
    10: .same(proto: "COLOR9"),
    11: .same(proto: "COLOR10"),
  ]
}

extension ProtonPassVaultV1_VaultDisplayPreferences: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VaultDisplayPreferences"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "icon"),
    2: .same(proto: "color"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.icon) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.color) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.icon != .iconUnspecified {
      try visitor.visitSingularEnumField(value: self.icon, fieldNumber: 1)
    }
    if self.color != .colorUnspecified {
      try visitor.visitSingularEnumField(value: self.color, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtonPassVaultV1_VaultDisplayPreferences, rhs: ProtonPassVaultV1_VaultDisplayPreferences) -> Bool {
    if lhs.icon != rhs.icon {return false}
    if lhs.color != rhs.color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtonPassVaultV1_Vault: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vault"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "display"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._display) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try { if let v = self._display {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtonPassVaultV1_Vault, rhs: ProtonPassVaultV1_Vault) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._display != rhs._display {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
